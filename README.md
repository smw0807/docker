# 마스터와 노드

클러스터 관리를 담당하는 마스터, 컨테이너화된 애플리케이션을 실제로 실행하는 노드
마스터는 마스터 노드, 노드는 워커 노드라고도 한다.

마스터는 kubectl과 같은 API 클라이언트로부터 요청을 받아서 애플리케이션의 배포, 스케일 업/다운 컨테이너의 버전 업 등의 요구를 처리한다.
마스터는 쿠버네티스 클러스터의 단일 장애점이 되지 않도록 다중화할 수 있다.

# 도커의 아키텍처

## 도커 데몬

클라이언트인 도커 커맨드 명령을 받아들여서 도커 오브젝트인 이미지, 컨테이너, 볼륨, 네트워크 등을 관리한다.
도커 데몬은 네트워크 너머에 있는 원격 클라이언트로부터 요청을 받는 것도 가능하다.

## 도커 클라이언트

도커 커맨드는 컨테이너를 조작하는 커맨드 라인 유저 인터페이스로 도커 데몬의 클라이언트다.
도커 커맨드는 도커 API를 사용하여 도커 데몬에 요청을 보낸다.

### 자주 사용하는 커맨드

`docker build` : 새로운 이미지를 만들 때 사용한다.  
`docker pull` : 레지스트리에서 이미지를 로컬에 다운로드할 때 사용한다.  
`docker run` : 이미지를 바탕으로 컨테이너를 실행한다.

## 이미지

읽기 전용인 컨테이너의 템플릿을 말한다.

## 컨테이너

하나의 프로세스로 볼 수 있고, 명확하게 표현하자면 ‘실행 가능한 이미지의 인스턴스’라고 할 수 있다.

## 도커 레지스트리

컨테이너의 이미지가 보관되는 곳이다.
도커는 기본으로 도커 허브에 있는 이미지를 찾도록 설정되어 있다.
개발한 컨테이너 이미지를 쿠버네티스에서 실행하기 위한 중간 창고와도 같은 존재이다.

레지스트리와 리포지터리는 이름이 비슷한데,
레지스트리는 리포지터리를 여러개 가지는 보관 서비스이다.
리포지터리는 하나의 이미지에 대해 태그를 사용하여 다양한 출시 버전을 함께 보관하는 곳이다.

## 퍼블릭 레지스트리

공개된 레지스트리이다.

## 클라우드 레지스트리

퍼블릭 레지스트리가 제공하는 레지스트리 서비스이다.
접근 가능한 계정을 제한하여 비공개로 운영할 수 있다.

## 비공개 레지스트리

회사나 팀 전용으로 레지스트리를 구축하여 운영하는 경우에 해당된다.

# 컨테이너를 위한 기술과 표준

## 리눅스 표준 규격과 리눅스 ABI(Application Binary Interface)

도커를 사용하면 다양한 리눅스 배포판을 기반으로 한 컨테이너 실행이 가능하다.

## 리눅스 커널 기술

### 네임스페이스(Namespace)

리눅스 커널에 사용된 기술로 컨테이너가 하나의 독립된 서버와 같이 동작할 수 있게 한다.
네임스페이스를 사용하면 특정 프로세스를 다른 프로세스로부터 분리시켜 같은 네임스페이스 내에서만 접근할 수 있도록 제한할 수 있다.

### 컨트롤 그룹(cgroup)

도커는 리눅스 커널의 cgroup을 사용한다.
cgroup은 프로세스별로 CPU 시간이나 메모리 사용량과 같은 자원을 감시하고 제한한다.

# 쿠버네티스 API 오브젝트

## 쿠버네티스 API 란?

쿠버네티스에 대한 조작은 모두 API를 통해 이뤄진다.
커맨드 라인 유저 인터페이스인 kubectl은 마스터 노드 상의 kube-apiserver에게 쿠버네티스 API 구약에 맞게 기술된 목표 상태 선언서인 매니패스트를 YAML 형식 혹은 JSON 형식으로 전송하여 오브젝트를 만들고, 바꾸고, 제거하는 일을 한다.

## 오브젝트란?

쿠버네티스 클러스터 내부의 엔티티로서, 파드, 컨트롤러, 서비스 등의 인스턴스를 의미한다.

각 오브젝트는 메타데이터에 기술된 이름에 의해 식별된다.
오브젝트를 만들 때는 반드시 이름을 부여해야 한다. 같은 종류의 오브젝트의 이름은 하나의 네임스페이스에서 반드시 유일해야 한다.

## 워크로드

오브젝트의 카테고리를 나타내는 용어로 컨테이너와 파드, 그리고 컨트롤러 그룹을 의미한다.
이들은 컨테이너의 실행을 관리하기 위해 사용된다.

## 컨테이너

쿠버네티스에서는 컨테이너만을 독자적으로 실행하는 것은 불가능하고, 반드시 파드 내에서 실행해야 한다.

## 파드(Pod)

파드는 컨테이너를 실행하기 위한 오브젝트다.
파드는 한 개 혹은 여러 개의 컨테이너를 담을 수 있다.

## 컨트롤러

파드의 실행을 제어하는 오브젝트로서, 여러 종류의 컨트롤러가 있어 각 컨트롤러의 기능을 이해하고 목적에 맞게 적절히 구별해서 사용해야 한다.

## 서비스

쿠버네티스에서의 서비스는 파드와 클라이언트를 연결하는 역할을 수행한다.

서버 역할을 수행하는 파드가 클라이언트의 요청을 받을 수 있도록 대표 IP 주소를 취득하여 내부 DNS에 등록한다. 그리고 대표 IP 주소로의 요청 트래픽을 지정된 파드들에 부하분산하며 전송하는 역할도 수행한다.

## 스토리지

파드나 컨테이너는 실행 시에만 존재하는 일시적인 존재이기 때문에 중요한 데이터를 컨테이너의 파일 시스템에 저장해서는 안된다.
데이터를 잃지 않기 위해서는 퍼시스턴트 볼륨을 사용하여 전원이 꺼져도 데이터가 유지되는 스토리지 시스템에 데이터를 저장해야 한다.
그런데 복수의 노드에서 접속 가능한 퍼시스턴트 볼륨은 쿠버네티스의 범위에 포함되지 않기 때문에 외부 스토리지 시스템을 연동해야 한다.

# 쿠버네티스 파드의 기본

## 컨테이너 재사용 촉진을 위한 플랫폼

1. 파드 내부의 컨테이너들은 파드의 IP 주소와 포트를 공유한다.
2. 파드 내부의 컨테이너들은 localhost로 서로 통신할 수 있다.
3. 파드 내부의 컨테이너들은 System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여 서로 통신할 수 있다.
4. 파드 내부의 컨테이너들은 파드의 볼륨을 마운트하여 파일 시스템을 공유할 수 있다.

위 기능들은 같은 파드 내의 컨테이너 사이에서만 가능하며, 다른 파드에 있는 컨터에너와는 불가능하다.

## 파드는 일시적인 존재

파드는 일시적인 존재로 설계되어 파드 내의 컨테이너는 이미지로부터 매번 생성된다.
즉, 같은 오브젝트 이름으로 몇 번이고 파드를 기동해도 이전 컨테이너에서 수행한 변경 이력은 남지 않고, 이미지의 초기 상태에서 시작할 뿐이다.

파드의 IP 주소 또한 고정적이지 않다. 파드의 IP 주소는 기동 시 부여되고, 종료 시 회수되어 다른 파드가 기동될 때 사용된다.
파드의 기동과 삭제는 컨트롤러에 의해 동적으로 실행되기 때문에 해당 파드가 언제까지 같은 IP 주소를 가지고 있을지 알 수 없다. 그래서 파드에 요청을 보내고 싶을 경우에는 반드시 서비스를 사용해야 한다.

## 파드는 컨테이너의 실행 상태를 관리

파드 내부의 컨테이너가 정지한 경우에는 파드가 해당 컨테이너를 재시작 한다.
설정에 따라서는 정지한 컨테이너를 그대로 유지한 채 로그를 참조할 수 있도록 하는 것도 가능하다.

파드는 활성 프로브(Liveness Probe)와 준비 상태 프로브(Readiness Probe)를 설정하여 내부 애플리케이션의 상태를 감시할 수 있다.

활성 프로브를 설정하면 애플리케이션이 멈춰 있는 상태를 감지하여 컨테이너를 강제 종료 시킬 수 있다.
준비 상태 프로브를 설정하면 파드가 요청을 받을 준비가 될 때까지 서비스 오브젝트가 요청을 전송하지 않는다.

## 파드는 초기화 전용 컨테이너를 실행

파드에 초기화만을 담당하는 컨테이너를 설정할 수 있다. 그러면 파드가 기동된 후 초기화 담당 컨테이너가 제일 먼저 실행되며 초기화가 끝나면 핵심 기능을 수행하는 컨테이너들이 실행된다.

## 정리

파드는 IP 주소를 가지며, 복수의 컨테이너를 내포하며, 하나의 가상 서버처럼 동작하지만, 기존 서버에 관리하던 것 처럼 친숙한 호스트 이름을 붙여 오랫동안 정성들여 관리하는 것과는 다른 방식으로 설계되었다. 즉, 쓰고 버리고 새롭게 시작할 수 있도록 설계된 것이다.
