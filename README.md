# 마스터와 노드

클러스터 관리를 담당하는 마스터, 컨테이너화된 애플리케이션을 실제로 실행하는 노드
마스터는 마스터 노드, 노드는 워커 노드라고도 한다.

마스터는 kubectl과 같은 API 클라이언트로부터 요청을 받아서 애플리케이션의 배포, 스케일 업/다운 컨테이너의 버전 업 등의 요구를 처리한다.
마스터는 쿠버네티스 클러스터의 단일 장애점이 되지 않도록 다중화할 수 있다.

# 도커의 아키텍처

## 도커 데몬

클라이언트인 도커 커맨드 명령을 받아들여서 도커 오브젝트인 이미지, 컨테이너, 볼륨, 네트워크 등을 관리한다.
도커 데몬은 네트워크 너머에 있는 원격 클라이언트로부터 요청을 받는 것도 가능하다.

## 도커 클라이언트

도커 커맨드는 컨테이너를 조작하는 커맨드 라인 유저 인터페이스로 도커 데몬의 클라이언트다.
도커 커맨드는 도커 API를 사용하여 도커 데몬에 요청을 보낸다.

### 자주 사용하는 커맨드

`docker build` : 새로운 이미지를 만들 때 사용한다.  
`docker pull` : 레지스트리에서 이미지를 로컬에 다운로드할 때 사용한다.  
`docker run` : 이미지를 바탕으로 컨테이너를 실행한다.

## 이미지

읽기 전용인 컨테이너의 템플릿을 말한다.

## 컨테이너

하나의 프로세스로 볼 수 있고, 명확하게 표현하자면 ‘실행 가능한 이미지의 인스턴스’라고 할 수 있다.

## 도커 레지스트리

컨테이너의 이미지가 보관되는 곳이다.
도커는 기본으로 도커 허브에 있는 이미지를 찾도록 설정되어 있다.
개발한 컨테이너 이미지를 쿠버네티스에서 실행하기 위한 중간 창고와도 같은 존재이다.

레지스트리와 리포지터리는 이름이 비슷한데,
레지스트리는 리포지터리를 여러개 가지는 보관 서비스이다.
리포지터리는 하나의 이미지에 대해 태그를 사용하여 다양한 출시 버전을 함께 보관하는 곳이다.

## 퍼블릭 레지스트리

공개된 레지스트리이다.

## 클라우드 레지스트리

퍼블릭 레지스트리가 제공하는 레지스트리 서비스이다.
접근 가능한 계정을 제한하여 비공개로 운영할 수 있다.

## 비공개 레지스트리

회사나 팀 전용으로 레지스트리를 구축하여 운영하는 경우에 해당된다.

# 컨테이너를 위한 기술과 표준

## 리눅스 표준 규격과 리눅스 ABI(Application Binary Interface)

도커를 사용하면 다양한 리눅스 배포판을 기반으로 한 컨테이너 실행이 가능하다.

## 리눅스 커널 기술

### 네임스페이스(Namespace)

리눅스 커널에 사용된 기술로 컨테이너가 하나의 독립된 서버와 같이 동작할 수 있게 한다.
네임스페이스를 사용하면 특정 프로세스를 다른 프로세스로부터 분리시켜 같은 네임스페이스 내에서만 접근할 수 있도록 제한할 수 있다.

### 컨트롤 그룹(cgroup)

도커는 리눅스 커널의 cgroup을 사용한다.
cgroup은 프로세스별로 CPU 시간이나 메모리 사용량과 같은 자원을 감시하고 제한한다.

# 쿠버네티스 API 오브젝트

## 쿠버네티스 API 란?

쿠버네티스에 대한 조작은 모두 API를 통해 이뤄진다.
커맨드 라인 유저 인터페이스인 kubectl은 마스터 노드 상의 kube-apiserver에게 쿠버네티스 API 구약에 맞게 기술된 목표 상태 선언서인 매니패스트를 YAML 형식 혹은 JSON 형식으로 전송하여 오브젝트를 만들고, 바꾸고, 제거하는 일을 한다.

## 오브젝트란?

쿠버네티스 클러스터 내부의 엔티티로서, 파드, 컨트롤러, 서비스 등의 인스턴스를 의미한다.

각 오브젝트는 메타데이터에 기술된 이름에 의해 식별된다.
오브젝트를 만들 때는 반드시 이름을 부여해야 한다. 같은 종류의 오브젝트의 이름은 하나의 네임스페이스에서 반드시 유일해야 한다.

## 워크로드

오브젝트의 카테고리를 나타내는 용어로 컨테이너와 파드, 그리고 컨트롤러 그룹을 의미한다.
이들은 컨테이너의 실행을 관리하기 위해 사용된다.

## 컨테이너

쿠버네티스에서는 컨테이너만을 독자적으로 실행하는 것은 불가능하고, 반드시 파드 내에서 실행해야 한다.

## 파드(Pod)

파드는 컨테이너를 실행하기 위한 오브젝트다.
파드는 한 개 혹은 여러 개의 컨테이너를 담을 수 있다.

## 컨트롤러

파드의 실행을 제어하는 오브젝트로서, 여러 종류의 컨트롤러가 있어 각 컨트롤러의 기능을 이해하고 목적에 맞게 적절히 구별해서 사용해야 한다.

## 서비스

쿠버네티스에서의 서비스는 파드와 클라이언트를 연결하는 역할을 수행한다.

서버 역할을 수행하는 파드가 클라이언트의 요청을 받을 수 있도록 대표 IP 주소를 취득하여 내부 DNS에 등록한다. 그리고 대표 IP 주소로의 요청 트래픽을 지정된 파드들에 부하분산하며 전송하는 역할도 수행한다.

## 스토리지

파드나 컨테이너는 실행 시에만 존재하는 일시적인 존재이기 때문에 중요한 데이터를 컨테이너의 파일 시스템에 저장해서는 안된다.
데이터를 잃지 않기 위해서는 퍼시스턴트 볼륨을 사용하여 전원이 꺼져도 데이터가 유지되는 스토리지 시스템에 데이터를 저장해야 한다.
그런데 복수의 노드에서 접속 가능한 퍼시스턴트 볼륨은 쿠버네티스의 범위에 포함되지 않기 때문에 외부 스토리지 시스템을 연동해야 한다.

# 쿠버네티스 파드의 기본

## 컨테이너 재사용 촉진을 위한 플랫폼

1. 파드 내부의 컨테이너들은 파드의 IP 주소와 포트를 공유한다.
2. 파드 내부의 컨테이너들은 localhost로 서로 통신할 수 있다.
3. 파드 내부의 컨테이너들은 System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여 서로 통신할 수 있다.
4. 파드 내부의 컨테이너들은 파드의 볼륨을 마운트하여 파일 시스템을 공유할 수 있다.

위 기능들은 같은 파드 내의 컨테이너 사이에서만 가능하며, 다른 파드에 있는 컨터에너와는 불가능하다.

## 파드는 일시적인 존재

파드는 일시적인 존재로 설계되어 파드 내의 컨테이너는 이미지로부터 매번 생성된다.
즉, 같은 오브젝트 이름으로 몇 번이고 파드를 기동해도 이전 컨테이너에서 수행한 변경 이력은 남지 않고, 이미지의 초기 상태에서 시작할 뿐이다.

파드의 IP 주소 또한 고정적이지 않다. 파드의 IP 주소는 기동 시 부여되고, 종료 시 회수되어 다른 파드가 기동될 때 사용된다.
파드의 기동과 삭제는 컨트롤러에 의해 동적으로 실행되기 때문에 해당 파드가 언제까지 같은 IP 주소를 가지고 있을지 알 수 없다. 그래서 파드에 요청을 보내고 싶을 경우에는 반드시 서비스를 사용해야 한다.

## 파드는 컨테이너의 실행 상태를 관리

파드 내부의 컨테이너가 정지한 경우에는 파드가 해당 컨테이너를 재시작 한다.
설정에 따라서는 정지한 컨테이너를 그대로 유지한 채 로그를 참조할 수 있도록 하는 것도 가능하다.

파드는 활성 프로브(Liveness Probe)와 준비 상태 프로브(Readiness Probe)를 설정하여 내부 애플리케이션의 상태를 감시할 수 있다.

활성 프로브를 설정하면 애플리케이션이 멈춰 있는 상태를 감지하여 컨테이너를 강제 종료 시킬 수 있다.
준비 상태 프로브를 설정하면 파드가 요청을 받을 준비가 될 때까지 서비스 오브젝트가 요청을 전송하지 않는다.

## 파드는 초기화 전용 컨테이너를 실행

파드에 초기화만을 담당하는 컨테이너를 설정할 수 있다. 그러면 파드가 기동된 후 초기화 담당 컨테이너가 제일 먼저 실행되며 초기화가 끝나면 핵심 기능을 수행하는 컨테이너들이 실행된다.

## 정리

파드는 IP 주소를 가지며, 복수의 컨테이너를 내포하며, 하나의 가상 서버처럼 동작하지만, 기존 서버에 관리하던 것 처럼 친숙한 호스트 이름을 붙여 오랫동안 정성들여 관리하는 것과는 다른 방식으로 설계되었다. 즉, 쓰고 버리고 새롭게 시작할 수 있도록 설계된 것이다.

# 쿠버네티스 서비스의 기본

쿠버네티스의 서비스는 클라이언트의 요청을 파드에 전달하는 역할 담당이다.
파드의 IP 주소가 기동할 때마다 바뀌기 때문에 필요하다.
그래서 파드에 접속해야하는 클라이언트는 서비스가 가지는 대표 IP를 사용해서 접속해야 한다.

1. 서비스는 로드밸런서의 역할을 가지며, 클라이언트의 요청을 받기 위한 대표 IP 주소를 획득한다.
2. 서비스의 이름은 내부 DNS에 등록되기 때문에 클라이언트는 서비스의 이름만으로 서비스의 IP 주소를 획득할 수 있다.
3. 서비스는 실렉터에 지정된 라벨과 일치하는 파드 중 하나에게 요청을 전달한다.
4. 서비스가 만들어지고 나서 기동된 파드의 컨테이너에는 서비스에 대한 정보가 담긴 환경 변수가 자동으로 할당된다.
5. 서비스에는 4 종류의 서비스 타입이 있어, 클라이언트의 범위를 쿠버네티스 클러스터 내부로 한정할지, 외부까지 확장할지, 또한 쿠버네티스 클러스터 외부의 IP 주소에 전송할지 설정한다.

파드는 기동될 때 라벨이나 IP주소를 포함한 자신의 오브젝트 정보를 마스터 노드의 etcd에 등록한다.
그래서 서비스의 전송처를 결정할 때 실렉터(selector)의 라벨에 일치하는 파드를 etcd에서 조회하여 전송할 파드의 IP 주소를 취득한다.
이처럼 라벨에 의한 대상 오브젝트를 결정하는 것이 쿠버네티스의 기본적인 동작이다.

## 대표 IP 주소

서비스는 파드의 그룹을 대표하여 클라이언트의 요청을 받기 위해 대표 IP 주소(ClusterIP)를 가진다.
헤드리스로 지정한 경우에는 대표 IP 주소를 획득하기 않고, 파드의 IP 주소를 직접 내부 DNS에 설정한다.

## 부하분산

서비스의 대표 IP 주소에 도착한 요청은 실렉터의 라벨과 일치하는 파드에 전송된다.
이를 위한 모듈인 kube-proxy가 있지만 지금은 iptables나 ipvs를 관리하는 프로그램으로 바뀌었다.

## 이름 해결

서비스는 IP 주소와 서비스명을 쿠버네티스 클러스터의 내부 DNS에 등록한다.
그래서 쿠버네티스 클러스터 내의 파드에서는 서비스 이름으로 접근하는 것이 가능하다.

## 환경 변수

서비스가 만들어지고 나서 생성되는 파드의 컨테이너에는 환경 변수가 설정되어있다.
컨테이너 안의 애플리케이션 코드에서는 환경 변수를 이용해서 서비스의 대표 IP 주소를 얻을 수 있다.

## 서비스 타입

서비스를 설정할 때는 해당 서비스를 이용하는 클라이언트를 고려하여 서비스 타입을 지정한다.
쿠버네티스 클러스터 내부 파드를 대상으로 하는 경우와 쿠버네티스 클러스터 외부에서 접근하는 경우를 고려하여 지정한다.

## 어피니티

기본적으로 부하분산에 사용되는 알고리즘은 랜덤이다.
클라이언트에 따라 전송되는 파드를 고정하고 싶은 경우에는 sessionAffinity 항목에 Client IP를 설정한다.
그리고 HTTP 헤드 안의 쿠키 값에 따라 전송되는 파드를 고정하고 싶은 경우에는 인그레스를 이용해야 한다.

## 실렉터와 라벨

서비스에 도달한 요청 트래픽이 파드에 전송될 때는 실렉터와 라벨을 참조한다.
라벨은 파드 등의 오브젝트에 부여하는 키값 쌍이다.
서비스에 도착한 요청은 실렉터에 설정된 조건에 일치하는 라벨을 가지는 파드에 전송한다.
실렉터의 라벨 조건이나 파드에 부여되는 라벨은 운영 중에도 바꿀 수 있어 유연하게 운영할 수 있다.
