# 마스터와 노드

클러스터 관리를 담당하는 마스터, 컨테이너화된 애플리케이션을 실제로 실행하는 노드
마스터는 마스터 노드, 노드는 워커 노드라고도 한다.

마스터는 kubectl과 같은 API 클라이언트로부터 요청을 받아서 애플리케이션의 배포, 스케일 업/다운 컨테이너의 버전 업 등의 요구를 처리한다.
마스터는 쿠버네티스 클러스터의 단일 장애점이 되지 않도록 다중화할 수 있다.

# 도커의 아키텍처

## 도커 데몬

클라이언트인 도커 커맨드 명령을 받아들여서 도커 오브젝트인 이미지, 컨테이너, 볼륨, 네트워크 등을 관리한다.
도커 데몬은 네트워크 너머에 있는 원격 클라이언트로부터 요청을 받는 것도 가능하다.

## 도커 클라이언트

도커 커맨드는 컨테이너를 조작하는 커맨드 라인 유저 인터페이스로 도커 데몬의 클라이언트다.
도커 커맨드는 도커 API를 사용하여 도커 데몬에 요청을 보낸다.

### 자주 사용하는 커맨드

`docker build` : 새로운 이미지를 만들 때 사용한다.  
`docker pull` : 레지스트리에서 이미지를 로컬에 다운로드할 때 사용한다.  
`docker run` : 이미지를 바탕으로 컨테이너를 실행한다.

## 이미지

읽기 전용인 컨테이너의 템플릿을 말한다.

## 컨테이너

하나의 프로세스로 볼 수 있고, 명확하게 표현하자면 ‘실행 가능한 이미지의 인스턴스’라고 할 수 있다.

## 도커 레지스트리

컨테이너의 이미지가 보관되는 곳이다.
도커는 기본으로 도커 허브에 있는 이미지를 찾도록 설정되어 있다.
개발한 컨테이너 이미지를 쿠버네티스에서 실행하기 위한 중간 창고와도 같은 존재이다.

레지스트리와 리포지터리는 이름이 비슷한데,
레지스트리는 리포지터리를 여러개 가지는 보관 서비스이다.
리포지터리는 하나의 이미지에 대해 태그를 사용하여 다양한 출시 버전을 함께 보관하는 곳이다.

## 퍼블릭 레지스트리

공개된 레지스트리이다.

## 클라우드 레지스트리

퍼블릭 레지스트리가 제공하는 레지스트리 서비스이다.
접근 가능한 계정을 제한하여 비공개로 운영할 수 있다.

## 비공개 레지스트리

회사나 팀 전용으로 레지스트리를 구축하여 운영하는 경우에 해당된다.

# 컨테이너를 위한 기술과 표준

## 리눅스 표준 규격과 리눅스 ABI(Application Binary Interface)

도커를 사용하면 다양한 리눅스 배포판을 기반으로 한 컨테이너 실행이 가능하다.

## 리눅스 커널 기술

### 네임스페이스(Namespace)

리눅스 커널에 사용된 기술로 컨테이너가 하나의 독립된 서버와 같이 동작할 수 있게 한다.
네임스페이스를 사용하면 특정 프로세스를 다른 프로세스로부터 분리시켜 같은 네임스페이스 내에서만 접근할 수 있도록 제한할 수 있다.

### 컨트롤 그룹(cgroup)

도커는 리눅스 커널의 cgroup을 사용한다.
cgroup은 프로세스별로 CPU 시간이나 메모리 사용량과 같은 자원을 감시하고 제한한다.

# 쿠버네티스 API 오브젝트

## 쿠버네티스 API 란?

쿠버네티스에 대한 조작은 모두 API를 통해 이뤄진다.
커맨드 라인 유저 인터페이스인 kubectl은 마스터 노드 상의 kube-apiserver에게 쿠버네티스 API 구약에 맞게 기술된 목표 상태 선언서인 매니패스트를 YAML 형식 혹은 JSON 형식으로 전송하여 오브젝트를 만들고, 바꾸고, 제거하는 일을 한다.

## 오브젝트란?

쿠버네티스 클러스터 내부의 엔티티로서, 파드, 컨트롤러, 서비스 등의 인스턴스를 의미한다.

각 오브젝트는 메타데이터에 기술된 이름에 의해 식별된다.
오브젝트를 만들 때는 반드시 이름을 부여해야 한다. 같은 종류의 오브젝트의 이름은 하나의 네임스페이스에서 반드시 유일해야 한다.

## 워크로드

오브젝트의 카테고리를 나타내는 용어로 컨테이너와 파드, 그리고 컨트롤러 그룹을 의미한다.
이들은 컨테이너의 실행을 관리하기 위해 사용된다.

## 컨테이너

쿠버네티스에서는 컨테이너만을 독자적으로 실행하는 것은 불가능하고, 반드시 파드 내에서 실행해야 한다.

## 파드(Pod)

파드는 컨테이너를 실행하기 위한 오브젝트다.
파드는 한 개 혹은 여러 개의 컨테이너를 담을 수 있다.

## 컨트롤러

파드의 실행을 제어하는 오브젝트로서, 여러 종류의 컨트롤러가 있어 각 컨트롤러의 기능을 이해하고 목적에 맞게 적절히 구별해서 사용해야 한다.

## 서비스

쿠버네티스에서의 서비스는 파드와 클라이언트를 연결하는 역할을 수행한다.

서버 역할을 수행하는 파드가 클라이언트의 요청을 받을 수 있도록 대표 IP 주소를 취득하여 내부 DNS에 등록한다. 그리고 대표 IP 주소로의 요청 트래픽을 지정된 파드들에 부하분산하며 전송하는 역할도 수행한다.

## 스토리지

파드나 컨테이너는 실행 시에만 존재하는 일시적인 존재이기 때문에 중요한 데이터를 컨테이너의 파일 시스템에 저장해서는 안된다.
데이터를 잃지 않기 위해서는 퍼시스턴트 볼륨을 사용하여 전원이 꺼져도 데이터가 유지되는 스토리지 시스템에 데이터를 저장해야 한다.
그런데 복수의 노드에서 접속 가능한 퍼시스턴트 볼륨은 쿠버네티스의 범위에 포함되지 않기 때문에 외부 스토리지 시스템을 연동해야 한다.

# 쿠버네티스 파드의 기본

## 컨테이너 재사용 촉진을 위한 플랫폼

1. 파드 내부의 컨테이너들은 파드의 IP 주소와 포트를 공유한다.
2. 파드 내부의 컨테이너들은 localhost로 서로 통신할 수 있다.
3. 파드 내부의 컨테이너들은 System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여 서로 통신할 수 있다.
4. 파드 내부의 컨테이너들은 파드의 볼륨을 마운트하여 파일 시스템을 공유할 수 있다.

위 기능들은 같은 파드 내의 컨테이너 사이에서만 가능하며, 다른 파드에 있는 컨터에너와는 불가능하다.

## 파드는 일시적인 존재

파드는 일시적인 존재로 설계되어 파드 내의 컨테이너는 이미지로부터 매번 생성된다.
즉, 같은 오브젝트 이름으로 몇 번이고 파드를 기동해도 이전 컨테이너에서 수행한 변경 이력은 남지 않고, 이미지의 초기 상태에서 시작할 뿐이다.

파드의 IP 주소 또한 고정적이지 않다. 파드의 IP 주소는 기동 시 부여되고, 종료 시 회수되어 다른 파드가 기동될 때 사용된다.
파드의 기동과 삭제는 컨트롤러에 의해 동적으로 실행되기 때문에 해당 파드가 언제까지 같은 IP 주소를 가지고 있을지 알 수 없다. 그래서 파드에 요청을 보내고 싶을 경우에는 반드시 서비스를 사용해야 한다.

## 파드는 컨테이너의 실행 상태를 관리

파드 내부의 컨테이너가 정지한 경우에는 파드가 해당 컨테이너를 재시작 한다.
설정에 따라서는 정지한 컨테이너를 그대로 유지한 채 로그를 참조할 수 있도록 하는 것도 가능하다.

파드는 활성 프로브(Liveness Probe)와 준비 상태 프로브(Readiness Probe)를 설정하여 내부 애플리케이션의 상태를 감시할 수 있다.

활성 프로브를 설정하면 애플리케이션이 멈춰 있는 상태를 감지하여 컨테이너를 강제 종료 시킬 수 있다.
준비 상태 프로브를 설정하면 파드가 요청을 받을 준비가 될 때까지 서비스 오브젝트가 요청을 전송하지 않는다.

## 파드는 초기화 전용 컨테이너를 실행

파드에 초기화만을 담당하는 컨테이너를 설정할 수 있다. 그러면 파드가 기동된 후 초기화 담당 컨테이너가 제일 먼저 실행되며 초기화가 끝나면 핵심 기능을 수행하는 컨테이너들이 실행된다.

## 정리

파드는 IP 주소를 가지며, 복수의 컨테이너를 내포하며, 하나의 가상 서버처럼 동작하지만, 기존 서버에 관리하던 것 처럼 친숙한 호스트 이름을 붙여 오랫동안 정성들여 관리하는 것과는 다른 방식으로 설계되었다. 즉, 쓰고 버리고 새롭게 시작할 수 있도록 설계된 것이다.

# 쿠버네티스 서비스의 기본

쿠버네티스의 서비스는 클라이언트의 요청을 파드에 전달하는 역할 담당이다.
파드의 IP 주소가 기동할 때마다 바뀌기 때문에 필요하다.
그래서 파드에 접속해야하는 클라이언트는 서비스가 가지는 대표 IP를 사용해서 접속해야 한다.

1. 서비스는 로드밸런서의 역할을 가지며, 클라이언트의 요청을 받기 위한 대표 IP 주소를 획득한다.
2. 서비스의 이름은 내부 DNS에 등록되기 때문에 클라이언트는 서비스의 이름만으로 서비스의 IP 주소를 획득할 수 있다.
3. 서비스는 실렉터에 지정된 라벨과 일치하는 파드 중 하나에게 요청을 전달한다.
4. 서비스가 만들어지고 나서 기동된 파드의 컨테이너에는 서비스에 대한 정보가 담긴 환경 변수가 자동으로 할당된다.
5. 서비스에는 4 종류의 서비스 타입이 있어, 클라이언트의 범위를 쿠버네티스 클러스터 내부로 한정할지, 외부까지 확장할지, 또한 쿠버네티스 클러스터 외부의 IP 주소에 전송할지 설정한다.

파드는 기동될 때 라벨이나 IP주소를 포함한 자신의 오브젝트 정보를 마스터 노드의 etcd에 등록한다.
그래서 서비스의 전송처를 결정할 때 실렉터(selector)의 라벨에 일치하는 파드를 etcd에서 조회하여 전송할 파드의 IP 주소를 취득한다.
이처럼 라벨에 의한 대상 오브젝트를 결정하는 것이 쿠버네티스의 기본적인 동작이다.

## 대표 IP 주소

서비스는 파드의 그룹을 대표하여 클라이언트의 요청을 받기 위해 대표 IP 주소(ClusterIP)를 가진다.
헤드리스로 지정한 경우에는 대표 IP 주소를 획득하기 않고, 파드의 IP 주소를 직접 내부 DNS에 설정한다.

## 부하분산

서비스의 대표 IP 주소에 도착한 요청은 실렉터의 라벨과 일치하는 파드에 전송된다.
이를 위한 모듈인 kube-proxy가 있지만 지금은 iptables나 ipvs를 관리하는 프로그램으로 바뀌었다.

## 이름 해결

서비스는 IP 주소와 서비스명을 쿠버네티스 클러스터의 내부 DNS에 등록한다.
그래서 쿠버네티스 클러스터 내의 파드에서는 서비스 이름으로 접근하는 것이 가능하다.

## 환경 변수

서비스가 만들어지고 나서 생성되는 파드의 컨테이너에는 환경 변수가 설정되어있다.
컨테이너 안의 애플리케이션 코드에서는 환경 변수를 이용해서 서비스의 대표 IP 주소를 얻을 수 있다.

## 서비스 타입

서비스를 설정할 때는 해당 서비스를 이용하는 클라이언트를 고려하여 서비스 타입을 지정한다.
쿠버네티스 클러스터 내부 파드를 대상으로 하는 경우와 쿠버네티스 클러스터 외부에서 접근하는 경우를 고려하여 지정한다.

## 어피니티

기본적으로 부하분산에 사용되는 알고리즘은 랜덤이다.
클라이언트에 따라 전송되는 파드를 고정하고 싶은 경우에는 sessionAffinity 항목에 Client IP를 설정한다.
그리고 HTTP 헤드 안의 쿠키 값에 따라 전송되는 파드를 고정하고 싶은 경우에는 인그레스를 이용해야 한다.

## 실렉터와 라벨

서비스에 도달한 요청 트래픽이 파드에 전송될 때는 실렉터와 라벨을 참조한다.
라벨은 파드 등의 오브젝트에 부여하는 키값 쌍이다.
서비스에 도착한 요청은 실렉터에 설정된 조건에 일치하는 라벨을 가지는 파드에 전송한다.
실렉터의 라벨 조건이나 파드에 부여되는 라벨은 운영 중에도 바꿀 수 있어 유연하게 운영할 수 있다.

# 쿠버네티스 컨트롤러의 기본

컨트롤러는 파드를 제어한다.
파드에게 부여할 워크로드의 타입, 즉 처리에 따라서 적절한 컨트롤러를 선택해야 한다.

| 컨트롤러              | ← 제어 →            | 파드 파드 파드 파드      |
| --------------------- | ------------------- | ------------------------ |
| 컨트롤러의 종류       | 컨트롤 내용         | 워크로드 타입            |
| 디플로이먼트          | 기동/정지/삭제      | 프론트엔드 처리          |
| 레플리카셋            | 파드의 개수         | 백엔드 서비스            |
| 레플리케이션 컨트롤러 | 자기 회복           | 처리 시간이 긴 배치 처리 |
| 스테이트풀셋          | 퍼시스턴트 스토리지 | 정기 실행 작업           |
| 잡                    | 디플로이 스케줄     | 클러스터의 시스템 기능   |
| 크론잡                |                     |                          |
| 데몬셋                |                     |                          |
| 가비지 컬렉션 등      |                     |                          |

## 워크로드 타입

### 프론트엔드 처리

스마트폰, IoT 기기, 컴퓨터 등의 클라이언트로부터 요청을 직접 받아들이는 워크로드를 총칭한다.
이 타입의 워크로드는 대량의 클라이언트 요청에 대해 짧은 시간에 응답을 반환하는 것이 중요하다.

이 특성에 대응하기 위해서는 요청에 대응하는 처리를 복수의 파드에서 분담하도록 설계해야 한다.
또한, 24시간 무정지로 서비스를 제공하면서도 빠르게 신기능을 배포할 수 있어야 한다.

### 백엔드 처리

백엔드 처리는 프론트엔드의 뒤에서 업무의 특성에 맞게 대응할 수 있는 유연상이 있어야 한다.
요청량이 변하더라도 일정한 응답 속도를 유지해야 하며, 요구 사항에 맞게 단 기간에 기능을 추가하고 변경하는 것이 가능해야 한다.

백엔드 처리는 보통 MySQL, Redis와 같은 미들웨어를 사용하거나 클라우드 사업자가 제공하는 데이터베이스 관리 서비스를 활용한다.

1. 데이터 스토어 : 데이터의 보존과 조회 기능(SQL/NoSQL 데이터베이스 등)
2. 캐시 : 복수의 파드에서 데이터 공유 (세션 정보 공유 등)
3. 메시징 : 비동기 시스템 간 연계 기능(메시지 브로커 등)
4. 마이크로 서비스 : 전문적 업무 기능 구현(결제, 배송, 결제 승인 등)
5. 배치 처리 : 긴 처리 시간을 요하는 업무 기능(기계 학습이나 데이터 분석 등)

### 배치 처리(정기 실행 처리 포함)

배치 처리는 어떠 트리거에 의해 실행이 개시된다.
프론트엔드로부터의 요청, 정해진 시간, 단말로부터의 수시 요청 등
배치 처리 내용은 다양하다.
동영상 포맷 변환, 대량 메일 송수신, 과학 계산, GPU를 사용한 딥러닝 등

### 시스템 운영 처리

시스템 운영을 돕기 위해서 쿠버네티스 API를 사용해서 노드에서 발생하는 에러나 하드웨어 이상을 감지하고 자동으로 대책을 실행하는 파드를 만드는 경우가 있다.

## 컨트롤러의 타입

컨트롤러는 다양한 워크로드를 처리하기 위해 파드를 제어하고 실행하는 역할을 담당한다.

### 디플로이먼트(Deployment)

대등한 관계에 있는 여러 개의 파드로 수평한 클러스터를 구성할 때 사용한다.
정해진 개수만큼 파드가 기동하도록 관리하며, 가동 중인 파드를 차례대로 교체하거나 규모를 조절할 수 있는 기능을 갖추고 있다.

### 스테이트풀셋(StatefulSet)

파드와 퍼시스턴트 볼륨을 조합하여 데이터의 보관에 초점을 둔 컨트롤러다.
파드와 퍼시스턴트 볼륨에 번호를 매겨 관리함으로써 본질적으로 일시적인 존재인 파드가 상태를 가지는 워크로드를 처리할 수 있도록 해준다.

### 잡(Job)

배치 처리를 하는 컨테이너가 정상 종료 할 때까지 재실행을 반복하는 컨트롤러다.
파드 실행 횟수, 동시 실행수, 실행 횟수의 상한을 설정할 수 있으며, 지워질 때까지 로그를 보존한다.
데이터 처리나 과학 분야의 계산 작업 등에 사용된다.

### 크론잡(CronJob)

지정한 시간에 잡을 생성한다.
UNIX에서 사용되는 cron과 같은 형식으로 잡의 생성 시각을 설정할 수 있다.
잡을 실행 완료한 파드를 몇 개까지 보관할 수 있는지 설정할 수 있어, 정기적으로 실행되어야 하는 배치 처리에 적합하다.

### 데몬셋(DaemonSet)

쿠버네티스 클러스터의 모든 노드에서 같은 파드를 실행하기 위해 존재한다.
예를 들면, 클러스터 네트워크를 구성하는 파드는 데몬셋에 의해 모든 노드에서 실행되며, 새로운 노드가 추가되면 해당 노드에서 자동 실행된다.
시스템 운영의 자동화에 적합하다.

### 레플리카셋(ReplicaSet)

디플로이먼트 컨트롤러와 연동해서 파드가 기동되어야 하는 수를 관리한다.
레플리카셋은 직접 다루기보다는 디플로이먼트를 통해 이용하는 것이 기본이다.

### 레플리케이션 컨트롤러(Replication Controller)

차세대 컨트롤러인 디플로이먼트로 대체됨

## 워크로드와 컨트롤러의 대응

| 워크로드 타입   | 컨트롤러 타입 |
| --------------- | ------------- |
| 프론트엔드 처리 | 디플로이먼트  |
| 백엔드 처리     | 스테이트풀셋  |
| 배치 처리       | 잡, 크론잡    |
| 시스템 운영     | 데몬셋        |

CPU 코어수, 메모리 증성 등 노드의 스케일 업과 같은 기능은 컨트롤러가 제공하지 않는다.
노드 스케일 업은 클라우드에서의 경우, 보다 많은 CPU 코어 수나 메모리 용량을 탑재한 노드를 준비해서 쿠버네티스 클러스터에 추가한 후, 파드의 노드 실렉터를 설정해서 마이그레이션해야 한다.

## 마무리

1. 쿠버네티스 클러스터는 마스터와 노드로 구성된다.
2. CNCF가 배포하는 쿠버네티스가 기본이며, 클라우드 업체나 솔루션 업체들이 자사 제품을 위해 독자적으로 기능을 추가하거나 확장하기도 한다.
3. 마스터는 목표 상태가 기술된 매니페스트를 받아들여서 그 상태가 유지되도록 오브젝트를 제어한다.
4. 쿠버네티스 클러스터의 모든 조작은 쿠버네티스 API에 의해 실행되며, 오브젝트 작성, 수정, 삭제, 상태 조회 등을 실행한다.
5. 주요 오브젝트는 파드, 컨트롤러, 서비스 세 가지가 있다.
6. 파드는 컨테이너의 기동 단위이며, 보통 서비스와 컨트롤러와 함께 사용된다.
7. 컨테이너 내 프로그램의 시그널 처리는 데이터 손실을 막고 안전하게 종료하도록 구현되어야 한다.
8. 서비스는 클라이언트로부터의 요청을 지정한 파드의 그룹에 부하분산하며 전송하는 역할을 담당한다.
9. 워크로드의 특성에 맞게 컨트롤러를 선택해서 쿠버네티스를 사용해야 한다.
